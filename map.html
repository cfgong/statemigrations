<!DOCTYPE html>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<style>
h1 {
  font-family:arial;
  font-size:2em;
  color:#333;
}
#info {
  position:absolute;
  top: 10px;
  left: 10px;
}
.states {
	fill: #e5e5e5;
	stroke: #fff;
	stroke-width:2px;
}
.states:hover {
	fill: steelblue;
}
.arcs {
  stroke-width: 2px;
  stroke: tomato;
  pointer-events: none;
  fill: none;
}
</style>
<body">
<div id="info"><h1 id="name"></h1></div>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="http://d3js.org/topojson.v1.min.js"></script>
<script>

var width = 960,
	height = 500;

var svg = d3.select('body').append('svg')
	.attr('width', width)
	.attr('height', height);


var projection = d3.geo.albersUsa()
	.scale(1000)
	.translate([width / 2, height / 2]);

var path = d3.geo.path()
	.projection(projection);

var state_centers = {};

d3.csv("/data/cleaned/state_centers.csv", function(data){
  data.forEach(function(d){
    var stateName = d["state"].replace(/\s+/g, '');
    state_centers[stateName] = [+d["longtitude"], +d["latitude"]];
  });
});

// the list of years we are looking at
var dates = []
for (var i = 2013; i <= 2017; i++){
  dates.push(i.toString());
}

// year to year data dict
var incoming_states_all = {};
var outgoing_states_all = {};
// function to populate dicts by reading csvs
function load_in_csv(dateYear){
  var incoming_states = {};
  var outgoing_states = {};
  var dataPath = "/data/cleaned/state"+dateYear+".csv";
  dataPath = "/data/cleaned/state2016.csv";
  d3.csv(dataPath, function(data){
    data.forEach(function(d){
      var starting_state = d["starting"].replace(/\s+/g, '').toString();
      var ending_state = d["ending"].replace(/\s+/g, '').toString();

      incoming_states[starting_state] = ending_state;

      var outgoing_states_list = outgoing_states[ending_state];
      if (outgoing_states_list == undefined){
        outgoing_states[ending_state] = new Array();
        outgoing_states[ending_state].push([starting_state]);
      } else {
        outgoing_states[ending_state].push([starting_state]);
      }
      
    });
  });
  incoming_states_all[dateYear] = incoming_states;
  outgoing_states_all[dateYear] = outgoing_states;
}

// create a range for all the years
var dates = new Array(); 
for (var i = 2013; i <= 2017; i++){
  dates.push(i.toString());
}
// load in data for all the years
for (var i = 0; i < dates.length; i++){
  load_in_csv(dates[i]);
}
// set year
var currYear = "2015";

d3.json('states.json', function(error, us) {
	svg.selectAll('.states')
		.data(topojson.feature(us, us.objects.usStates).features)
		.enter()
		.append('path')
		.attr('class', 'states')
		.attr('d', path)
		.on('mouseover', function(d){
			var name = d.properties.STATE_ABBR.replace(/\s+/g, '');
			return drawArcs(name);
		})
    .on('mouseout', function(d){
      var name = d.properties.STATE_ABBR.replace(/\s+/g, '');
      var svg_id = "#" + name;
      var outgoing_id = "." + name + "outgoing";
      d3.select(svg_id).remove();
      d3.select(outgoing_id).remove();
    });

    function drawArcs(state) {
      var outgoing_states = outgoing_states_all[currYear];
      var incoming_states = incoming_states_all[currYear];
      console.log("This is the state: "+ state);
      var incoming = incoming_states[state];
      var curr_state_center = state_centers[state];
      var incoming_state_center = state_centers[incoming];
      var outgoing = outgoing_states[state];
      var outgoingcoords = [];
      if (outgoing != undefined ) {
        for (var i = 0; i < outgoing.length; i++) {
          var coord = state_centers[outgoing[i]];
          outgoingcoords.push({
          type: "LineString",
          coordinates: [
              coord,
              curr_state_center
          ]
          });
        }
    }

      var links = [];
      links.push({
            type: "LineString",
            coordinates: [
                curr_state_center,
                incoming_state_center
            ]
        });
      //console.log(state + " has incoming state " + incoming + " from " + incoming_state_center + " to " + curr_state_center);
      svg = svg.append("g")
               .attr("class", "arcs");

      svg.selectAll('.arcs')
         .data(links)
         .enter()
         .append('path')
         .attr('id', state)
         .attr('d', function(d) {
               return drawArrowArcs(d, 0, 1);
         });

   if (outgoing != undefined ) {
    var classname = "" + state + "outgoing";
    var outgoingArcs = svg.append("g").attr("class", classname);
     outgoingArcs.selectAll('.' + classname)
        .data(outgoingcoords)
        .enter()
        .append('path')
        .attr('d', function(d) {
              return drawArrowArcs(d, 0, 1);
        });
     }
   }
});

function drawArrowArcs(d, sourceName, targetName) {
      var sourceLngLat = d['coordinates'][sourceName],
          targetLngLat = d['coordinates'][targetName];
        var origin = projection(sourceLngLat);
        var dest = projection(targetLngLat);
        var mid = [ (origin[0] + dest[0]) / 2, (origin[1] + dest[1]) / 2];


        //define handle points for Bezier curves. Higher values for curveoffset will generate more pronounced curves.

        var curveoffset = 20,
        midcurve = [mid[0]+curveoffset, mid[1]-curveoffset]
        // the scalar variable is used to scale the curve's derivative into a unit vector
        scalar = Math.sqrt(Math.pow(dest[0],2) - 2*dest[0]*midcurve[0]+Math.pow(midcurve[0],2)+Math.pow(dest[1],2)-2*dest[1]*midcurve[1]+Math.pow(midcurve[1],2));


        // define the arrowpoint: the destination, minus a scaled tangent vector, minus an orthogonal vector scaled to the datum.trade variable

        arrowpoint = [
          dest[0] - ( 0.5*15*(dest[0]-midcurve[0]) -15*(dest[1]-midcurve[1]) ) / scalar ,
          dest[1] - ( 0.5*15*(dest[1]-midcurve[1]) - 15*(-dest[0]+midcurve[0]) ) / scalar
        ];

        // move cursor to origin
        return "M" + origin[0] + ',' + origin[1]
        // smooth curve to offset midpoint
         + "S" + midcurve[0] + "," + midcurve[1]
        //smooth curve to destination
         + "," + dest[0] + "," + dest[1]
        //straight line to arrowhead point
         + "L" + arrowpoint[0] + "," + arrowpoint[1]
        // straight line towards original curve along scaled orthogonal vector (creates notched arrow head)
         + "l" + (0.3*40*(-dest[1]+midcurve[1])/scalar) + "," + (0.3*40*(dest[0]-midcurve[0])/scalar)
        // smooth curve to midpoint
         + "S" + (midcurve[0]) + "," + (midcurve[1])
        //smooth curve to origin
         + "," + origin[0] + "," + origin[1]
}


function lngLatToArc(d, sourceName, targetName, bend){
      // If no bend is supplied, then do the plain square root
      bend = bend || 1;
      // `d[sourceName]` and `d[targetname]` are arrays of `[lng, lat]`
      // Note, people often put these in lat then lng, but mathematically we want x then y which is `lng,lat`

      var sourceLngLat = d['coordinates'][sourceName],
          targetLngLat = d['coordinates'][targetName];
      console.log(sourceLngLat);
      console.log(targetLngLat);

      if (targetLngLat && sourceLngLat) {
        var sourceXY = projection( sourceLngLat ),
            targetXY = projection( targetLngLat );

        // Uncomment this for testing, useful to see if you have any null lng/lat values
        // if (!targetXY) console.log(d, targetLngLat, targetXY)
        var sourceX = sourceXY[0],
            sourceY = sourceXY[1];

        var targetX = targetXY[0],
            targetY = targetXY[1];

        var dx = targetX - sourceX,
            dy = targetY - sourceY,
            dr = Math.sqrt(dx * dx + dy * dy)*bend;

        // To avoid a whirlpool effect, make the bend direction consistent regardless of whether the source is east or west of the target
        var west_of_source = (targetX - sourceX) < 0;
        if (west_of_source) return "M" + targetX + "," + targetY + "A" + dr + "," + dr + " 0 0,1 " + sourceX + "," + sourceY;
        return "M" + sourceX + "," + sourceY + "A" + dr + "," + dr + " 0 0,1 " + targetX + "," + targetY;

      } else {
        return "M0,0,l0,0z";
      }
}


</script>
</body>
</html>
